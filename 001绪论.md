## 绪论

### 计算

对象：规律、技巧

目标：高效、低耗

>   Computer science should be called computing science, for the same reason why surgery is not called knife science.
>
>   —— E. Dijkstra

#### 绳索计算机及其算法

输入：任给直线1及其上一点A

输出：经过A做1到一条垂线

算法：取12段等长的绳索，首尾联接成环，从A点起，将4段绳索沿1抻直并固定于B，沿另一方向找到第3段绳索的终点C，移动点C，将剩余的3+5段绳索抻直

![image-20200105101613290](http://linupyoos.oss-cn-beijing.aliyuncs.com/blogs/2020-01-05-021613.png)

#### 尺规计算机及其算法

任给平面上线段AB（输入），将其三等分（输出）

![image-20200105101922967](http://linupyoos.oss-cn-beijing.aliyuncs.com/blogs/2020-01-05-021940.png)

#### 算法

-   计算 = 信息处理

    记住某种工具，按照一定规则，以明确而机械的形式进行

-   计算模型 = 计算机 = 信息处理工具

    所谓算法，即在特定计算模型下，旨在解决特定问题的指令序列

    1.  输入：待处理的信息（问题）
    2.   输出：经处理的信息（答案）
    3.  正确性：的确可以解决指定的问题
    4.  确定性：任一算法都可以描述为一个由基本操作组成的序列
    5.  可行性：每一基本操作都可以实现，且在常数时间内完成
    6.  有穷性：对于任何输入，经过有穷次基本操作，都可以得到输出

#### 算法有穷性

序列$Hailstone = \begin{cases} {1} & n \leq 1 \\ \{n\} \bigcup Hailstone(n/2) & n \text偶 \\ \{n\} \bigcup Hailstone(3n+1) & n \text奇 \end{cases}$

例子：

Hailstone(42)  = {42, 21, 64, 32, ....,1}

数字有可能持续下降，但不会持续上升

程序：

```c
int hailstone(int n){ //计算诉累Hailstone(n)的长度
	int length = 1; //从1开始，以下按定义逐步递推，并累计步数，直至 n = 1
	while(1 < n){
		(n % 2) ? n = 3*n+1 : n/=2;
		length++;
	}
	return length; //返回|Hailstone(n)|
}
```

Hailstone(7) = {7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16,..,1}

Hailstone(27) = {27, 82, 41, 124, 62, 31, 94, 47, 142, 71, 214, 107, ...}

对于任意的n，总有|Hailstone(n)| < ∞ ?   *不一定*

***程序未必是算法***

#### 好算法

-   正确：符合语法，能够编译、链接

    -   能够正确处理简单的输入
    -   能够正确大规模的输入
    -   能够正确处理一般性的输入
    -   能够正确处理退化的输入
    -   能够争取额处理任意合法的输入

-   健壮：能辨别不合法的输入并做适当处理，而不致非正常退出

-   可读：结构化 + 准确命名 + 注释 + ...

-   **效率**：速度尽可能快；存储空间尽可能少（最重要）

    （既要马儿快快跑，又要马儿吃的少）

### 计算模型

计算来自于实际应用的现实需求，需要高效低耗的运行。在算法和数据结构两个方面着手，二者有机结合。

好的计算必然对应着好的数据结构和算法，反之亦然。

高效、低耗

>   To  measure is to know.
>
>   If you can not measure it, you can not impore it.
>
>   —— Lord Kelvin

#### 算法分析

-   两个主要方面

    -   正确性

    算法功能与问题要求是否一致

    -   成本

        运行时间 + 所需存储空间

-   考察： $T_A(P)$  = 算法A求解问题实例P的计算成本，意义不大，毕竟可能出现的问题实例太多

    如何归纳概括？

-   观察：问题实例的规模，往往是决定计算成本的主要因素

-   通常：规模接近，计算成本也接近；规模扩大，计算成本亦上升

#### 特定算法 + 不同实例

令 $T_A(n)$  = 用算法A求解某一问题规模为n的实例，所需的计算成本讨论特定算法A（及其对应的问题）时，简记做$T(n)$

然而，这一定义仍有问题...

观察：同一问题等规模的不同实例，计算成本不尽相同，甚至有实质差别

例如：在平面上的n个点中，找到所成三角形面积最小的三个点，以蛮力算法为例，最坏情况下需枚举所有$C(n,3)$种组合，但运气好的话... 

![image-20200105114040013](http://linupyoos.oss-cn-beijing.aliyuncs.com/blogs/2020-01-05-034040.png)

既然如此，又该如何定义$T(n)$呢？稳妥起见，取$T(n) = max \{ T(P) | |P| = n \}$，也就是说，在规模同为n的所有实例中，只关注最坏（或成本最高）者。（关心复杂度的上界）

#### 图灵机

同一个问题通常有多种算法，如何评判其优劣？

实验统计是最直接的方法，但足以准确反映算法的真正效率？

不足够！，因为：

-   不同的算法，可能更适应于不同规模的输入
-   不同的算法，可能更适应于不同类型的输入
-   同一算法，可能由不同的程序员、不同程序语言、经不同的编译器实现
-   同一算法，可能实现并运行于不同的体系结构、操作系统...

为了给出客观的评判，需要抽象出一个理想的平台或模型

-   不再依赖于上述种种具体的因素
-   从而直接而准确的描述、测量并评价算法

>不是真正的去做一个现实中的物理的实验，而是在头脑中去做一个虚拟的、理想的但是又能够反映事物本质的实验。
>
>——物理学家 伽利略

图灵机（Turing Machine）有一下几个要件：

![image-20200105130822389](http://linupyoos.oss-cn-beijing.aliyuncs.com/blogs/2020-01-05-050822.png)

-   Tape

    依次均匀地划分为单元格，各注有某一字符，默认为'#'

-   Alphabet字符的种类有限

-   Head

    总是对准某一单元格，并可读取和改写其中的字符，每经过一个节拍，可转向左侧或者右侧的邻格

-   State

    TM总是处于有限状态中的某一种，每经过一个节拍，可（按照规则）转向另一种状态

-   Transition Function:(q, c; d, L/R, p)

    若当前状态为q且当前字符为c，则将当前字符改写为d；转向左侧/右侧的邻格；转入p状态

    一旦转入特定的状态'h'，则停机

具体实例：

功能：将二进制非负整数加一

算法：全'1'的后缀翻转为全'0'，原最低位的'0'或'#'翻转为'1'

![image-20200105143046962](http://linupyoos.oss-cn-beijing.aliyuncs.com/blogs/2020-01-05-063047.png)

#### RAM模型

RAM——Random Access Machine

![image-20200105143515651](http://linupyoos.oss-cn-beijing.aliyuncs.com/blogs/2020-01-05-063515.png)

![image-20200105144115910](http://linupyoos.oss-cn-beijing.aliyuncs.com/blogs/2020-01-05-064115.png)

下溢：不再是一个正数

### 大O记号

>   Mathematics is more in find of good notations than of new theorems.
>
>   —— Alan Turing

大O记号好的地方：

>   好读书，不求甚解，每有会意，便欣然忘食。
>
>   ——陶渊明

#### 渐进分析

回到原先的问题，随着问题规模的增长，计算成本如何增长？

注意：这里更关系足够大的问题，注重考察成本的增长趋势

渐进分析：在问题规模足够大后，计算成本如何增长？

Asymptotic analysis：当$n>>2$后，对于规模为n输入，算法：

-   需执行的基本操作次数：$T(n)$ = ?
-   需占用的存储单元数：$S(n)$ = ？（通常可以不考虑）

![image-20200105145046614](http://linupyoos.oss-cn-beijing.aliyuncs.com/blogs/2020-01-05-065047.png)

x轴：问题的规模。y轴：相应的计算成本

需要关心的并不是这条曲线局部的、细微的、暂时的趋势，而是主要的、长远的、变化的趋势

#### 大O记号

大O记号：big-O natation

$T(n) = O(f(n)) \ \ iff \ \ \exists \ c > 0,\text当 \ n>>2 \ \text后，有 \ T(n) < c·f(n)$

充要条件

存在常数c大于0，当n足够大的时候，$T(n)$绝对不会超过$f(n)$的c常数倍

例子：

第一个开方经过3次转化，最终得到了$O(n^{15})$

$\sqrt{5n\cdot[3n(n+2)+4]+6} < \sqrt{5n\cdot[6n^2+4]+6} < \sqrt{35n^3+6} < 6\cdot n^{15} = O(n^{15})$

![image-20200105165418485](http://linupyoos.oss-cn-beijing.aliyuncs.com/blogs/2020-01-05-085418.png)

与$T(n)$相比，$f(n)$更为简洁，但依然反映前者的增长趋势

-   常系数可忽略：$O(f(n)) = O(c\times f(n))$

-   低次项可忽略：$O(n^a+n^b) = O(n^a), \ a>b>0$

![image-20200105170027657](http://linupyoos.oss-cn-beijing.aliyuncs.com/blogs/2020-01-05-090027.png)

 #### 其他记号



















